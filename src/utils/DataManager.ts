import { Task } from '../types/Task';
import { DatabaseService, DatabaseTask, DatabaseMeditationSession, DatabaseUserSettings } from './supabaseClient';

export interface UserSettings {
  location: string | null;
  themeMode: 'light' | 'dark';
}

export interface MeditationSession {
  id: string;
  duration: number;
  date: Date;
  completion: boolean;
  createdAt: Date;
}

// Supabase-only data manager for cloud-first architecture
export class DataManager {
  private static instance: DataManager;
  private isOnline: boolean = navigator.onLine;
  private userEmail: string | null = null;
  private syncSubscription: any = null;

  static getInstance(): DataManager {
    if (!DataManager.instance) {
      DataManager.instance = new DataManager();
    }
    return DataManager.instance;
  }

  private constructor() {
    // Monitor online status
    window.addEventListener('online', () => {
      this.isOnline = true;
      console.log('Connection restored');
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
      console.log('Connection lost');
    });
  }

  async initialize(userEmail: string): Promise<void> {
    this.userEmail = userEmail;
    
    if (this.isOnline) {
      await this.setupCloudSync();
    }
  }

  // Task management
  async getTasks(): Promise<Task[]> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    try {
      const dbTasks = await DatabaseService.getTasks(this.userEmail);
      return dbTasks.map(this.convertDbTaskToTask);
    } catch (error: any) {
      console.error('Failed to fetch tasks:', error);
      
      // Check if this is a table not found error
      if (error.code === 'PGRST116' || error.code === 'PGRST205' || 
          error.message?.includes('Could not find the table') ||
          error.message?.includes('schema cache')) {
        const dbError = new Error('Database tables not found. Please set up the database first.');
        (dbError as any).code = error.code || 'PGRST205';
        throw dbError;
      }
      
      throw error;
    }
  }

  async addTask(taskData: Omit<Task, 'id' | 'completed' | 'createdAt'>): Promise<Task> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    const dbTask = this.convertTaskToDbTask({
      ...taskData,
      id: '', // Will be generated by database
      completed: false,
      createdAt: new Date()
    });

    try {
      const createdTask = await DatabaseService.createTask(dbTask);
      return this.convertDbTaskToTask(createdTask);
    } catch (error: any) {
      console.error('Failed to create task:', error);
      
      if (error.code === 'PGRST116' || error.code === 'PGRST205' || 
          error.message?.includes('Could not find the table') ||
          error.message?.includes('schema cache')) {
        const dbError = new Error('Database tables not found. Please set up the database first.');
        (dbError as any).code = error.code || 'PGRST205';
        throw dbError;
      }
      
      throw error;
    }
  }

  async updateTask(id: string, updates: Partial<Task>): Promise<void> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    try {
      const dbUpdates = this.convertTaskUpdatesToDbUpdates(updates);
      await DatabaseService.updateTask(id, dbUpdates);
    } catch (error: any) {
      console.error('Failed to update task:', error);
      
      if (error.code === 'PGRST116' || error.code === 'PGRST205' || 
          error.message?.includes('Could not find the table') ||
          error.message?.includes('schema cache')) {
        const dbError = new Error('Database tables not found. Please set up the database first.');
        (dbError as any).code = error.code || 'PGRST205';
        throw dbError;
      }
      
      throw error;
    }
  }

  async deleteTask(id: string): Promise<void> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    try {
      await DatabaseService.deleteTask(id);
    } catch (error: any) {
      console.error('Failed to delete task:', error);
      
      if (error.code === 'PGRST116' || error.code === 'PGRST205' || 
          error.message?.includes('Could not find the table') ||
          error.message?.includes('schema cache')) {
        const dbError = new Error('Database tables not found. Please set up the database first.');
        (dbError as any).code = error.code || 'PGRST205';
        throw dbError;
      }
      
      throw error;
    }
  }

  // Meditation session management
  async addMeditationSession(session: Omit<MeditationSession, 'id' | 'createdAt'>): Promise<void> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    try {
      const dbSession: Omit<DatabaseMeditationSession, 'id' | 'created_at'> = {
        duration: session.duration,
        date: session.date.toISOString(),
        completion: session.completion,
        user_email: this.userEmail
      };
      await DatabaseService.createMeditationSession(dbSession);
    } catch (error) {
      console.error('Failed to save meditation session:', error);
      throw error;
    }
  }

  async getMeditationSessions(days: number = 7): Promise<MeditationSession[]> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    try {
      const dbSessions = await DatabaseService.getMeditationSessions(this.userEmail, days);
      return dbSessions.map(session => ({
        id: session.id,
        duration: session.duration,
        date: new Date(session.date),
        completion: session.completion,
        createdAt: new Date(session.created_at)
      }));
    } catch (error) {
      console.error('Failed to fetch meditation sessions:', error);
      throw error;
    }
  }

  // User settings management
  async getUserSettings(): Promise<UserSettings> {
    if (!this.userEmail) {
      return {
        location: null,
        themeMode: 'light'
      };
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    try {
      const dbSettings = await DatabaseService.getUserSettings(this.userEmail);
      if (dbSettings) {
        return {
          location: dbSettings.location,
          themeMode: dbSettings.theme_mode
        };
      }
    } catch (error) {
      console.error('Failed to fetch user settings:', error);
    }

    return {
      location: null,
      themeMode: 'light'
    };
  }

  async updateUserSettings(updates: Partial<UserSettings>): Promise<void> {
    if (!this.userEmail) {
      throw new Error('User not authenticated');
    }

    if (!this.isOnline) {
      throw new Error('No internet connection');
    }

    const currentSettings = await this.getUserSettings();
    const newSettings = { ...currentSettings, ...updates };

    try {
      const dbSettings: Omit<DatabaseUserSettings, 'id' | 'created_at' | 'updated_at'> = {
        user_email: this.userEmail,
        theme_mode: newSettings.themeMode,
        sync_preferences: 'cloud-sync', // Always cloud sync now
        location: newSettings.location
      };
      await DatabaseService.upsertUserSettings(dbSettings);
    } catch (error) {
      console.error('Failed to save user settings:', error);
      throw error;
    }
  }

  // Utility methods
  getSyncStatus(): { mode: 'cloud-sync'; online: boolean; connected: boolean } {
    return {
      mode: 'cloud-sync',
      online: this.isOnline,
      connected: this.isOnline
    };
  }

  async testCloudConnection(): Promise<boolean> {
    try {
      return await DatabaseService.testConnection();
    } catch {
      return false;
    }
  }

  cleanup(): void {
    this.teardownCloudSync();
  }

  // Private helper methods
  private async setupCloudSync(): Promise<void> {
    if (!this.userEmail) return;

    try {
      // Set up real-time subscription
      this.syncSubscription = DatabaseService.subscribeToTasks(this.userEmail, (payload) => {
        console.log('Real-time update:', payload);
        this.handleRealtimeUpdate(payload);
      });
    } catch (error) {
      console.warn('Failed to set up cloud sync:', error);
    }
  }

  private teardownCloudSync(): void {
    if (this.syncSubscription) {
      this.syncSubscription.unsubscribe();
      this.syncSubscription = null;
    }
  }

  private handleRealtimeUpdate(payload: any): void {
    // Handle real-time database updates
    console.log('Handling real-time update:', payload);
    // This would trigger UI updates when other clients modify data
  }

  private convertTaskToDbTask(task: Task): Omit<DatabaseTask, 'id' | 'created_at'> {
    return {
      title: task.title,
      description: task.description,
      deadline: task.deadline?.toISOString() || null,
      priority: task.priority,
      completed: task.completed,
      user_email: this.userEmail!
    };
  }

  private convertDbTaskToTask(dbTask: DatabaseTask): Task {
    return {
      id: dbTask.id,
      title: dbTask.title,
      description: dbTask.description,
      deadline: dbTask.deadline ? new Date(dbTask.deadline) : undefined,
      priority: dbTask.priority,
      completed: dbTask.completed,
      createdAt: new Date(dbTask.created_at)
    };
  }

  private convertTaskUpdatesToDbUpdates(updates: Partial<Task>): Partial<DatabaseTask> {
    const dbUpdates: Partial<DatabaseTask> = {};
    
    if (updates.title !== undefined) dbUpdates.title = updates.title;
    if (updates.description !== undefined) dbUpdates.description = updates.description;
    if (updates.deadline !== undefined) dbUpdates.deadline = updates.deadline?.toISOString() || null;
    if (updates.priority !== undefined) dbUpdates.priority = updates.priority;
    if (updates.completed !== undefined) dbUpdates.completed = updates.completed;
    
    return dbUpdates;
  }
}